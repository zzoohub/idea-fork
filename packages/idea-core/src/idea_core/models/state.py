"""
LangGraph state definitions for the idea generation pipeline.

Defines the state schema that flows through the graph nodes.
"""

from enum import Enum
from typing import Any, Optional
from typing_extensions import TypedDict


class GenerationStatus(str, Enum):
    """Status of the generation pipeline."""

    QUEUED = "queued"
    GENERATING_CONCEPT = "generating_concept"
    EXPANDING_PRD = "expanding_prd"
    CATEGORIZING = "categorizing"
    SAVING = "saving"
    COMPLETED = "completed"
    FAILED = "failed"


class GenerationProgress(TypedDict):
    """Progress tracking for the generation pipeline."""

    status: GenerationStatus
    current_step: int
    total_steps: int
    message: str


class IdeaConcept(TypedDict):
    """Initial idea concept generated by the first node."""

    title: str
    problem: str
    solution: str
    target_users: str
    key_features: list[str]


class PRDContent(TypedDict):
    """Full PRD content structure."""

    executive_summary: str
    problem_definition: str
    market_analysis: str
    user_personas: list[dict[str, str]]
    features: list[dict[str, str]]
    tech_stack: dict[str, list[str]]
    mvp_roadmap: list[dict[str, str]]
    success_metrics: list[dict[str, str]]


class GeneratedIdea(TypedDict):
    """Complete generated idea with all fields."""

    title: str
    problem: str
    solution: str
    target_users: str
    key_features: list[str]
    prd_content: PRDContent
    categories: list[str]


class IdeaGenerationState(TypedDict):
    """State for the idea generation pipeline.

    This state flows through all nodes in the graph:
    1. generate_concept: Creates initial idea concept
    2. expand_prd: Expands concept into full PRD
    3. categorize: Assigns categories
    4. save: Persists to database

    Attributes:
        run_id: Unique identifier for this generation run
        idea_index: Index of current idea (0-based) in multi-idea runs
        available_categories: List of category slugs from database
        concept: Initial idea concept
        prd_content: Expanded PRD content
        categories: Assigned category slugs
        idea_id: Database ID after saving (None until saved)
        idea_slug: URL slug after saving (None until saved)
        error: Error message if any step fails
        completed: Whether pipeline completed successfully

        # Fork-related fields
        forked_from_id: ID of the idea being forked (None for new ideas)
        fork_modifications: Optional modifications to apply when forking

        # User context
        user_id: ID of the user requesting generation (None for scheduled jobs)

        # Progress tracking
        progress: Current generation progress for status updates

        # Callback for progress updates (not serialized)
        progress_callback: Optional callback function for progress updates
    """

    # Run metadata
    run_id: str
    idea_index: int
    available_categories: list[str]

    # Pipeline outputs (populated progressively)
    concept: Optional[IdeaConcept]
    prd_content: Optional[PRDContent]
    categories: Optional[list[str]]

    # Final state
    idea_id: Optional[int]
    idea_slug: Optional[str]
    error: Optional[str]
    completed: bool

    # Fork-related fields
    forked_from_id: Optional[str]
    fork_modifications: Optional[dict[str, Any]]

    # User context
    user_id: Optional[str]

    # Progress tracking
    progress: Optional[GenerationProgress]


def create_initial_state(
    run_id: str,
    idea_index: int,
    available_categories: list[str],
    user_id: Optional[str] = None,
) -> IdeaGenerationState:
    """Create initial state for a new idea generation.

    Args:
        run_id: Unique run identifier
        idea_index: Index of this idea in the batch
        available_categories: Available category slugs
        user_id: Optional user ID for on-demand generation

    Returns:
        Initial state for the pipeline
    """
    return IdeaGenerationState(
        run_id=run_id,
        idea_index=idea_index,
        available_categories=available_categories,
        concept=None,
        prd_content=None,
        categories=None,
        idea_id=None,
        idea_slug=None,
        error=None,
        completed=False,
        forked_from_id=None,
        fork_modifications=None,
        user_id=user_id,
        progress=GenerationProgress(
            status=GenerationStatus.QUEUED,
            current_step=0,
            total_steps=4,
            message="Queued for generation",
        ),
    )


def create_fork_state(
    run_id: str,
    forked_from_id: str,
    available_categories: list[str],
    user_id: Optional[str] = None,
    modifications: Optional[dict[str, Any]] = None,
) -> IdeaGenerationState:
    """Create initial state for forking an existing idea.

    Args:
        run_id: Unique run identifier
        forked_from_id: ID of the idea being forked
        available_categories: Available category slugs
        user_id: Optional user ID for on-demand generation
        modifications: Optional modifications to apply to the forked idea

    Returns:
        Initial state for the fork pipeline
    """
    return IdeaGenerationState(
        run_id=run_id,
        idea_index=0,
        available_categories=available_categories,
        concept=None,
        prd_content=None,
        categories=None,
        idea_id=None,
        idea_slug=None,
        error=None,
        completed=False,
        forked_from_id=forked_from_id,
        fork_modifications=modifications,
        user_id=user_id,
        progress=GenerationProgress(
            status=GenerationStatus.QUEUED,
            current_step=0,
            total_steps=4,
            message="Queued for fork generation",
        ),
    )
