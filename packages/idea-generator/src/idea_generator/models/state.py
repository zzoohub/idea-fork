"""
LangGraph state definitions for the idea generation pipeline.

Defines the state schema that flows through the graph nodes.
"""

from enum import Enum
from typing import Any, Optional

from typing_extensions import TypedDict


class GenerationStatus(str, Enum):
    """Status of the generation pipeline."""

    QUEUED = "queued"
    GENERATING_CONCEPT = "generating_concept"
    EXPANDING_PRD = "expanding_prd"
    CATEGORIZING = "categorizing"
    SAVING = "saving"
    COMPLETED = "completed"
    FAILED = "failed"


class GenerationProgress(TypedDict, total=False):
    """Progress tracking for the generation pipeline."""

    status: GenerationStatus  # Required
    current_step: int  # Required
    total_steps: int  # Required
    message: str  # Required

    # Optional fields (only on completion/failure)
    idea_id: Optional[int]
    idea_slug: Optional[str]
    error: Optional[str]


class IdeaConcept(TypedDict):
    """Initial idea concept generated by the first node."""

    title: str
    problem: str
    solution: str
    target_users: str
    key_features: list[str]


class PRDContent(TypedDict):
    """Full PRD content structure."""

    executive_summary: str
    problem_definition: str
    market_analysis: str
    user_personas: list[dict[str, str]]
    features: list[dict[str, str]]
    tech_stack: dict[str, list[str]]
    mvp_roadmap: list[dict[str, str]]
    success_metrics: list[dict[str, str]]


class TaxonomyClassification(TypedDict):
    """Taxonomy classification for an idea."""

    function_slug: str  # Required: what the product does
    industry_slug: Optional[str]  # Optional: target industry
    target_user_slug: Optional[str]  # Optional: primary audience


class GeneratedIdea(TypedDict):
    """Complete generated idea with all fields."""

    title: str
    problem: str
    solution: str
    target_users: str
    key_features: list[str]
    prd_content: PRDContent
    categories: list[str]  # Legacy, kept for compatibility
    taxonomy: TaxonomyClassification  # New taxonomy system


class IdeaGenerationState(TypedDict):
    """State for the idea generation pipeline.

    This state flows through all nodes in the graph:
    1. generate_concept: Creates initial idea concept
    2. expand_prd: Expands concept into full PRD
    3. categorize: Assigns taxonomy (industry, target_user)
    4. save: Persists to database

    Attributes:
        run_id: Unique identifier for this generation run
        idea_index: Index of current idea (0-based) in multi-idea runs
        target_function: Target function slug for idea generation
        target_industry: Target industry slug (pre-selected or random)
        idea_seed: Optional user-provided idea text for seed-based generation
        available_functions: List of function slugs from database
        available_industries: List of industry slugs from database
        available_target_users: List of target user slugs from database
        available_categories: List of category slugs (legacy, for compatibility)
        concept: Initial idea concept
        prd_content: Expanded PRD content
        taxonomy: Taxonomy classification (function, industry, target_user)
        categories: Assigned category slugs (legacy)
        idea_id: Database ID after saving (None until saved)
        idea_slug: URL slug after saving (None until saved)
        error: Error message if any step fails
        completed: Whether pipeline completed successfully

        # Fork-related fields
        forked_from_id: ID of the idea being forked (None for new ideas)
        fork_modifications: Optional modifications to apply when forking

        # User context
        user_id: ID of the user requesting generation (None for scheduled jobs)

        # Progress tracking
        progress: Current generation progress for status updates
    """

    # Run metadata
    run_id: str
    idea_index: int

    # Taxonomy inputs
    target_function: str  # Required: function to generate idea for
    target_industry: Optional[str]  # Pre-selected industry (None = AI decides)
    idea_seed: Optional[str]  # User-provided idea text for seed-based generation
    available_functions: list[str]
    available_industries: list[str]
    available_target_users: list[str]
    available_categories: list[str]  # Legacy, kept for compatibility

    # Pipeline outputs (populated progressively)
    concept: Optional[IdeaConcept]
    prd_content: Optional[PRDContent]
    taxonomy: Optional[TaxonomyClassification]
    categories: Optional[list[str]]  # Legacy

    # Final state
    idea_id: Optional[int]
    idea_slug: Optional[str]
    error: Optional[str]
    completed: bool

    # Fork-related fields
    forked_from_id: Optional[str]
    fork_modifications: Optional[dict[str, Any]]

    # User context
    user_id: Optional[str]

    # Progress tracking
    progress: Optional[GenerationProgress]


def create_initial_state(
    run_id: str,
    idea_index: int,
    target_function: str,
    available_functions: list[str],
    available_industries: list[str],
    available_target_users: list[str],
    available_categories: Optional[list[str]] = None,  # Legacy, optional
    target_industry: Optional[str] = None,
    idea_seed: Optional[str] = None,
    user_id: Optional[str] = None,
) -> IdeaGenerationState:
    """Create initial state for a new idea generation.

    Args:
        run_id: Unique run identifier
        idea_index: Index of this idea in the batch
        target_function: Function slug to generate idea for
        available_functions: Available function slugs
        available_industries: Available industry slugs
        available_target_users: Available target user slugs
        available_categories: Available category slugs (legacy)
        target_industry: Pre-selected industry slug (None = AI decides)
        idea_seed: User-provided idea text for seed-based generation
        user_id: Optional user ID for on-demand generation

    Returns:
        Initial state for the pipeline
    """
    return IdeaGenerationState(
        run_id=run_id,
        idea_index=idea_index,
        target_function=target_function,
        target_industry=target_industry,
        idea_seed=idea_seed,
        available_functions=available_functions,
        available_industries=available_industries,
        available_target_users=available_target_users,
        available_categories=available_categories or [],
        concept=None,
        prd_content=None,
        taxonomy=None,
        categories=None,
        idea_id=None,
        idea_slug=None,
        error=None,
        completed=False,
        forked_from_id=None,
        fork_modifications=None,
        user_id=user_id,
        progress=GenerationProgress(
            status=GenerationStatus.QUEUED,
            current_step=0,
            total_steps=4,
            message="Queued for generation",
        ),
    )


def create_fork_state(
    run_id: str,
    forked_from_id: str,
    target_function: str,
    available_functions: list[str],
    available_industries: list[str],
    available_target_users: list[str],
    available_categories: Optional[list[str]] = None,  # Legacy, optional
    user_id: Optional[str] = None,
    modifications: Optional[dict[str, Any]] = None,
) -> IdeaGenerationState:
    """Create initial state for forking an existing idea.

    Args:
        run_id: Unique run identifier
        forked_from_id: ID of the idea being forked
        target_function: Function slug for the forked idea
        available_functions: Available function slugs
        available_industries: Available industry slugs
        available_target_users: Available target user slugs
        available_categories: Available category slugs (legacy)
        user_id: Optional user ID for on-demand generation
        modifications: Optional modifications to apply to the forked idea

    Returns:
        Initial state for the fork pipeline
    """
    return IdeaGenerationState(
        run_id=run_id,
        idea_index=0,
        target_function=target_function,
        target_industry=None,
        idea_seed=None,
        available_functions=available_functions,
        available_industries=available_industries,
        available_target_users=available_target_users,
        available_categories=available_categories or [],
        concept=None,
        prd_content=None,
        taxonomy=None,
        categories=None,
        idea_id=None,
        idea_slug=None,
        error=None,
        completed=False,
        forked_from_id=forked_from_id,
        fork_modifications=modifications,
        user_id=user_id,
        progress=GenerationProgress(
            status=GenerationStatus.QUEUED,
            current_step=0,
            total_steps=4,
            message="Queued for fork generation",
        ),
    )
